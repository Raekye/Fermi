\documentclass{article}

\usepackage[left=1cm,top=1.2cm,right=1cm,bottom=1.2cm]{geometry}
\usepackage{mathtools}
\usepackage{tabularx}
\usepackage{float}
\usepackage{longtable}
\usepackage{tabu}
\usepackage{numprint}
\usepackage{listings}

\begin{document}

\title{Programming Language Reference}
\author{Adrian}
\date{\today}
\maketitle

\section{Prelude}
Hmmmmm.

\section{Ternary Operator}
\begin{longtabu} to 0.75\linewidth { X X }
	C & \lstinline$a ? b : c$ \\
	Lisp & \lstinline$if a b c$ \\
	Haskell & \lstinline$(if a then b else c)$ \\
	Erlang & \lstinline$case A of true -> B; false -> C end$ \newline \lstinline$if A == true -> B; true -> C end$ \\
	Python & \lstinline$b if a else c$ \\
	Ruby & \lstinline$if a then b elseif d then e else c end$ \newline \lstinline$(a \&\& b) || c$ \\
	Scala & \lstinline$if (a) b else c$ \\
	Perl & \lstinline$a ? b : c$ \\
\end{longtabu}

\section{List Construction}
\begin{longtabu} to 0.75\linewidth { X X }
	Lisp & \lstinline$(cons 1 (cons 2 nil))$ \\
	Scala & \lstinline$1 :: 2 :: Nil$ \\
	Haskell & \lstinline$1 : 2 : []$ \\
	Erlang & \lstinline$[1 | [2 | []]]$ \\
	Ruby & \lstinline$[] << 1 << 2$ \\
\end{longtabu}

\section{Arrays}
\begin{itemize}
	\item C
	\item Java
	\item Scala
\end{itemize}

\section{List API}
\subsection{Python}
\begin{lstlisting}[language=Python]
li.append(x)
li.index(x)
li.insert(i, x)
li.pop(i = -1)
li.remove(x) # void
len(li)
li.reverse()
\end{lstlisting}

\subsection{Ruby}
\begin{lstlisting}[language=Ruby]
a + b # extend
a & b # intersection
a - b # array difference
a | b # union
li.collect { |x| block } # map
li.count
li.count(x) # occurences of x
li.delete(x) # returns x
li.delete_at(i) # returns x
li.delete_if { |item| block } # list of elements deleted
li.each { |x| block }
li.each_index { |i| block }
li.empty?
li.index(x)
li.index { |item| block }
li.drop(n) # returns last length - n elements
li.first
li.first(n) # returns first n elements
li.last(n) # returns last n elements
li.take(n) # first n elements
li.insert(i, obj...)
li.map.with_index { |x, i| block }
li.pop # end
li.push(obj, ...) # end
li.shift # front
li.unshift(obj, ...) front
li.slice
li.sort
li.sort { |a, b| block }
li.zip(arr, ...) # merges elements, creating li.size lists
\end{lstlisting}

\subsection{Javascript}
\begin{lstlisting}

\end{lstlisting}

\subsection{Java}
\begin{lstlisting}[language=Java]

\end{lstlisting}

\subsection{C++}
\begin{lstlisting}[language=C++]

\end{lstlisting}

\subsection{Scala}
\begin{lstlisting}

\end{lstlisting}

\section{Slicing}
Hmmmmm

\section{List Comprehensions}
\begin{longtabu} to 0.75\linewidth { X X }
	Python & \lstinline$[x ** 2 for x in range(10) if x ** 2 > 3]$ \\
	Ruby & \lstinline$(1..10).select \{ |x| x ** 2 > 3 \}.collect \{ |X| 2 * x \}$ \\
	Scala & \lstinline$for (x <- 0 until 10 if x * x > 3) yield 2 * x$ \\
	Erlang & \lstinline$[2 * X || X <- lists:seq(0, 10), X * X > 3]$ \\
	Haskell & \lstinline$[2 * x | x <- [0..10], x ^ 2 > 3]$ \\
\end{longtabu}

\section{C++ Templates}
Hmmmm

\section{C Typedefs}
Hmmmm

\section{Lambdas}
\begin{longtabu} to 0.75\linewidth { X X }
	Javascript & \lstinline$function foo(x) \{ var y = x * 2; return y; \}$ \\
	Scala & \lstinline$(x: Int) => { val y = x * 2; /*newline*/ return x; }$ \\
	Ruby & \lstinline$lambda do |x| y = x * 2; return y; end$ \newline \lstinline$lambda \{ |x| y = x * 2; return y; \}$ \\
	Haskell & \lstinline$\\x -> x * 2$ \\
	Erlang & \lstinline$fun(Self, args) -> args; (_, X) -> X * 2 end$
\end{longtabu}

\section{Y-Combinator}
\begin{lstlisting}
function Y(le) {
    return (function(f) {
        return f(f);
    })(function(f) {
        return le(function(x) {
            return f(f)(x);
        });
    });
}

var factorial = Y(function(recurse) {
    return function(n) {
        return n == 0 ? 1 : n * recurse(n - 1);
    };
});
\end{lstlisting}

\section{Exceptions}
Java, Scala, Python, Ruby, C++, Javascript, PHP

\section{Objective-C Blocks}
Hmmmm

\section{Operator Precedence}
Hmmmm

\section{Iteration}
Java, C++, Python, Scala, Ruby, PHP, Javascript, Erlang, Haskell, Lisp

\section{Ranges}
\begin{longtabu} to 0.75\linewidth { X X X }
	Language & Exclusive & Inclusive \\
	\hline
	Scala & \lstinline$0 until n$ & \lstinline$0 to n$ \\
	Ruby & \lstinline$0...n$ & \lstinline$0..n$ \\
	Python & \lstinline$range(0, n)$ & \lstinline$range(0, n + 1)$ \\
	Haskell & \lstinline$[0..n - 1]$ & \lstinline$[0..n]$ \\
	Erlang & \lstinline$lists:seq(0, n - 1)$ & \lstinline$lists:seq(0, n)$ \\
\end{longtabu}

\section{Math}
\subsection{Exponentiation}
\begin{longtabu} to 0.75\linewidth { X X }
	C & \lstinline$pow(x, y)$ \\
	Scala & \lstinline$Math.pow(x, y)$ \\
	Java & \lstinline$Math.pow(x, y)$ \\
	Javascript & \lstinline$Math.pow(x, y)$ \\
	Erlang & \lstinline$math:pow(x, y)$ \\
	Ruby & \lstinline$x ** y$ \\
	Python & \lstinline$x ** y$ \\
	Haskell & \lstinline$(\^) :: (Num a, Integral b) => a -> b -> a$ \newline \lstinline$(\^\^) :: (Fractional a, Integral b) => a -> b -> a$ \newline \lstinline$(**) :: Floating a => a -> a -> a$ \\
\end{longtabu}

\subsection{Division}
\begin{longtabu} to 0.75\linewidth { X X X X }
	Family & Integer & Decimal & Truncate towards \\
	\hline
	C & \lstinline$a / b$ & \lstinline$(double) a / b$ & \\
	Python & \lstinline$a // b$ & \lstinline$a / b$ & \\
	Ruby & \lstinline$a / b$ & \lstinline$a.to_f / b$ & \\
	Erlang & \lstinline$A div B$ \newline \lstinline$floor(A / B)$ & \lstinline$A / B$ & \\
	Haskell & \lstinline$quot a b$ \newline \lstinline$div a b$ & \lstinline$a / b$ & \\
	Lisp & \lstinline$(floor (/ a b))$ & \lstinline$(/ a b)$ & \\
\end{longtabu}

\subsection{Remainder}
\begin{longtabu} to 0.75\linewidth { X X X }
	Family & Syntax & Same sign as \\
	\hline
	C & \lstinline$a \% b$ & Dividend \\
	Haskell & \lstinline$rem a b$ & Dividend \\
	Haskell & \lstinline$mod a b$ & Divisor \\
	Erlang & \lstinline$a rem b$ & Dividend \\
	Python & \lstinline$a \% b$ & Divisor \\
	Ruby & \lstinline$a \% b$ \newline \lstinline$modulo(a, b)$ & Divisor \\
	Ruby & \lstinline$remainder(a, b)$ & Dividend \\
	Lisp & \lstinline$(modulo a b)$ & Divisor \\
	Lisp & \lstinline$(remainder a b)$ & Dividend \\

\end{longtabu}

\section{Haskell Integer Types}
\begin{longtabu} to 0.75\linewidth { X X X }
	Instance & Classes & Description \\
	\hline
	Int & Num, Real, Integral & \\
	Integer & Num, Real, Integral & \\
	Float & Num, Real, RealFrac, Floating, RealFloat & \\
	Double & Num, Real, RealFrac, Floating, RealFloat & \\
\end{longtabu}
\begin{longtabu} to 0.75\linewidth { X X X }
	Class & Extends & Description \\
	\hline
	Num & & \\
	Real & Num & \\
	Fractional & Num & \\
	Integral & Real & \\
	RealFrac & Real, Fractional & \\
	Floating & Fractional & \\
	RealFloat & RealFrac, Floating & \\
\end{longtabu}

\section{Comments}
Hmmmmm

\section{Boolean and Logical Operators}
\begin{longtabu} to 0.75\linewidth{ X X X  X X X X }
	Language & And & Or & Not & Type & True & False \\
	\hline
	Haskell & \lstinline$\&\&$ & \lstinline$||$ & \lstinline$not$ & \lstinline$Bool$ & \lstinline$True$ & \lstinline$False$ \\
\end{longtabu}

\section{Gotchas}
\begin{itemize}
	\item Quot truncates towards 0, and rem has the same sign as the dividend. Div truncates towards negative infinity, and mod has the same sign as the divisor
\end{itemize}

\section{To learn}
\begin{itemize}
	\item perl
	\item pascal
	\item cobol
	\item fortran
	\item lua
\end{itemize}

\end{document}
