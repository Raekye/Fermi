\documentclass{article}

\usepackage[left=1cm,top=1.2cm,right=1cm,bottom=1.2cm]{geometry}
\usepackage{mathtools}
\usepackage{tabularx}
\usepackage{float}
\usepackage{longtable}
\usepackage{tabu}
\usepackage{numprint}
\usepackage{listings}
\usepackage{footnote}
\usepackage{hyperref}

\hypersetup{
	colorlinks=true,
	urlcolor=blue
}

\lstset{
	basicstyle=\ttfamily%\footnotesize
}

\begin{document}

\title{Programming Language Reference}
\author{Adrian}
\date{\today}
\maketitle

\section{Prelude}
Hmmmmm.

\section{Ternary Operator}
\begin{longtabu} to 0.75\linewidth { X X }
	C & \lstinline$a ? b : c$ \\
	Lisp & \lstinline$if a b c$ \\
	Haskell & \lstinline$(if a then b else c)$ \\
	Erlang & \lstinline$case A of true -> B; false -> C end$ \newline \lstinline$if A == true -> B; true -> C end$ \\
	Python & \lstinline$b if a else c$ \\
	Ruby & \lstinline$if a then b elseif d then e else c end$ \newline \lstinline$(a \&\& b) || c$ \\
	Scala & \lstinline$if (a) b else c$ \\
	Perl & \lstinline$a ? b : c$ \\
\end{longtabu}

\section{List Construction}
\begin{longtabu} to 0.75\linewidth { X X }
	Lisp & \lstinline$(cons 1 (cons 2 nil))$ \\
	Scala & \lstinline$1 :: 2 :: Nil$ \\
	Haskell & \lstinline$1 : 2 : []$ \\
	Erlang & \lstinline$[1 | [2 | []]]$ \\
	Ruby & \lstinline$[] << 1 << 2$ \\
\end{longtabu}

\section{Arrays}
\begin{itemize}
	\item C
	\item Java
	\item Scala
\end{itemize}

\section{List API}
\subsection{Python}
\begin{lstlisting}[language=Python]
li.append(x)
li.index(x)
li.insert(i, x)
li.pop(i = -1)
li.remove(x) # void
len(li)
li.reverse()
\end{lstlisting}

\subsection{Ruby}
\begin{lstlisting}[language=Ruby]
a + b # extend
a & b # intersection
a - b # array difference
a | b # union
li.collect { |x| block } # map
li.count
li.count(x) # occurences of x
li.delete(x) # returns x
li.delete_at(i) # returns x
li.delete_if { |item| block } # list of elements deleted
li.each { |x| block }
li.each_index { |i| block }
li.empty?
li.index(x)
li.index { |item| block }
li.drop(n) # returns last length - n elements
li.first
li.first(n) # returns first n elements
li.last(n) # returns last n elements
li.take(n) # first n elements
li.insert(i, obj...)
li.map.with_index { |x, i| block }
li.pop # end
li.push(obj, ...) # end
li.shift # front
li.unshift(obj, ...) front
li.slice
li.sort
li.sort { |a, b| block }
li.zip(arr, ...) # merges elements, creating li.size lists
\end{lstlisting}

\subsection{Javascript}
\begin{lstlisting}

\end{lstlisting}

\subsection{Java}
\begin{lstlisting}[language=Java]

\end{lstlisting}

\subsection{C++}
\begin{lstlisting}[language=C++]

\end{lstlisting}

\subsection{Scala}
\begin{lstlisting}

\end{lstlisting}

\section{Slicing}
Hmmmmm

\section{List Comprehensions}
\begin{longtabu} to 0.75\linewidth { X X }
	Python & \lstinline$[x ** 2 for x in range(10) if x ** 2 > 3]$ \\
	Ruby & \lstinline$(1..10).select \{ |x| x ** 2 > 3 \}.collect \{ |x| 2 * x \}$ \\
	Scala & \lstinline$for (x <- 0 until 10 if x * x > 3) yield 2 * x$ \\
	Erlang & \lstinline$[2 * X || X <- lists:seq(0, 10), X * X > 3]$ \\
	Haskell & \lstinline$[2 * x | x <- [0..10], x ^ 2 > 3]$ \\
\end{longtabu}

\section{C++ Templates}
\subsection{Function Templates}
\begin{lstlisting}[language=C++]
template <class T> // or typename
T addTwo(T data) {
	return T + 2;
}

addTwo(2);
\end{lstlisting}
class vs typename: \url{http://stackoverflow.com/questions/213121/use-class-or-typename-for-template-parameters}
\subsection{Class Templates}
\begin{lstlisting}[language=C++]
template <class T>
class Thing {
	T data;
public:
	T get() const {
		return data;
	}
	void set(T in) {
		data = in;
	}
}

Thing<int> intThing;
intThing.set(42);
intThing.get(); // 42
\end{lstlisting}
more: \url{http://www.codeproject.com/Articles/257589/An-Idiots-Guide-to-Cplusplus-Templates-Part-1}
\section{C Typedefs}
\begin{lstlisting}[language=C]
typedef int thing;
thing a; // OK
unsigned thing a; // not OK, can't mix with prefixes

typedef struct {
	int things[8];
	char moreStuff[4];
} s1; // can't refer to self
typedef struct node {
	int data;
	struct node *next;
} Node;

// function pointer typedef
typedef int (*MathFunc)(float, int);
 
int do_math(float arg1, int arg2) {
    return arg2;
}
 
int call_a_func(MathFunc call_this) {
    int output = call_this(5.5, 7);
    return output;
}
\end{lstlisting}
more: \url{http://en.wikipedia.org/wiki/Typedef}

\section{Lambdas}
\begin{longtabu} to 0.75\linewidth { X X }
	Javascript & \lstinline$function foo(x) \{ var y = x * 2; return y; \}$ \\
	Scala & \lstinline$(x: Int) => { val y = x * 2; /*newline*/ return x; }$ \\
	Ruby & \lstinline$lambda do |x| y = x * 2; return y; end$ \newline \lstinline$lambda \{ |x| y = x * 2; return y; \}$ \\
	Haskell & \lstinline$\\x -> x * 2$ \\
	Erlang & \lstinline$fun(Self, args) -> args; (_, X) -> X * 2 end$ \\
\end{longtabu}

\section{Y-Combinator}
\begin{lstlisting}
function Y(le) {
    return (function(f) {
        return f(f);
    })(function(f) {
        return le(function(x) {
            return f(f)(x);
        });
    });
}

var factorial = Y(function(recurse) {
    return function(n) {
        return n == 0 ? 1 : n * recurse(n - 1);
    };
});
\end{lstlisting}

\section{Exceptions}
Java, Scala, Python, Ruby, C++, Javascript, PHP

\section{Objective-C Blocks}
Hmmmm

\section{Operator Precedence}
\url{http://en.wikipedia.org/wiki/Comparison_of_programming_languages_%28syntax%29#Comments}

\section{Iteration}
Java, C++, Python, Scala, Ruby, PHP, Javascript, Erlang, Haskell, Lisp
\subsection{Ruby}
\begin{lstlisting}[language=Ruby]
for i in 0..n
	# hmmmm
end
\end{lstlisting}
\subsection{Fortran}
\begin{lstlisting}
do i=0,n
	! hmmm
end do
\end{lstlisting}
\subsection{Objective-C}
\begin{lstlisting}
for (id each in array) {
	// hmmm
}
\end{lstlisting}

\section{Ranges}
\begin{longtabu} to 0.75\linewidth { X X X }
	Language & Exclusive & Inclusive \\
	\hline
	Scala & \lstinline$0 until n$ & \lstinline$0 to n$ \\
	Ruby & \lstinline$0...n$ & \lstinline$0..n$ \\
	Python & \lstinline$range(0, n)$ & \lstinline$range(0, n + 1)$ \\
	Haskell & \lstinline$[0..n - 1]$ & \lstinline$[0..n]$ \\
	Erlang & \lstinline$lists:seq(0, n - 1)$ & \lstinline$lists:seq(0, n)$ \\
	Perl & \lstinline$(0..\$n - 1)$ & \lstinline$(0..n)$ \\
\end{longtabu}

\section{Math}
\subsection{Exponentiation}
\begin{longtabu} to 0.75\linewidth { X X }
	C & \lstinline$pow(x, y)$ \\
	Scala & \lstinline$Math.pow(x, y)$ \\
	Java & \lstinline$Math.pow(x, y)$ \\
	Javascript & \lstinline$Math.pow(x, y)$ \\
	Erlang & \lstinline$math:pow(x, y)$ \\
	Ruby & \lstinline$x ** y$ \\
	Python & \lstinline$x ** y$ \\
	Haskell & \lstinline$(\^) :: (Num a, Integral b) => a -> b -> a$ \newline \lstinline$(\^\^) :: (Fractional a, Integral b) => a -> b -> a$ \newline \lstinline$(**) :: Floating a => a -> a -> a$ \\
	Fortran & \lstinline$**$ \\
\end{longtabu}

\subsection{Division}
\begin{longtabu} to 0.75\linewidth { X X X X }
	Family & Integer & Decimal & Truncate towards \\
	\hline
	C & \lstinline$a / b$ & \lstinline$(double) a / b$ & \\
	Python & \lstinline$a // b$ & \lstinline$a / b$ & \\
	Ruby & \lstinline$a / b$ & \lstinline$a.to_f / b$ & \\
	Erlang & \lstinline$A div B$ \newline \lstinline$floor(A / B)$ & \lstinline$A / B$ & \\
	Haskell & \lstinline$quot a b$ \newline \lstinline$div a b$ & \lstinline$a / b$ & \\
	Lisp & \lstinline$(floor (/ a b))$ & \lstinline$(/ a b)$ & \\
\end{longtabu}

\subsection{Remainder}
\begin{longtabu} to 0.75\linewidth { X X X }
	Family & Syntax & Same sign as \\
	\hline
	C & \lstinline$a \% b$ & Dividend \\
	Haskell & \lstinline$rem a b$ & Dividend \\
	Haskell & \lstinline$mod a b$ & Divisor \\
	Erlang & \lstinline$a rem b$ & Dividend \\
	Python & \lstinline$a \% b$ & Divisor \\
	Ruby & \lstinline$a \% b$ \newline \lstinline$modulo(a, b)$ & Divisor \\
	Ruby & \lstinline$remainder(a, b)$ & Dividend \\
	Lisp & \lstinline$(modulo a b)$ & Divisor \\it
	Lisp & \lstinline$(remainder a b)$ & Dividend \\

\end{longtabu}

\section{Haskell Integer Types}
\begin{longtabu} to 0.75\linewidth { X X X }
	Instance & Classes & Description \\
	\hline
	Int & Num, Real, Integral & \\
	Integer & Num, Real, Integral & \\
	Float & Num, Real, RealFrac, Floating, RealFloat & \\
	Double & Num, Real, RealFrac, Floating, RealFloat & \\
\end{longtabu}
\begin{longtabu} to 0.75\linewidth { X X X }
	Class & Extends & Description \\
	\hline
	Num & & \\
	Real & Num & \\
	Fractional & Num & \\
	Integral & Real & \\
	RealFrac & Real, Fractional & \\
	Floating & Fractional & \\
	RealFloat & RealFrac, Floating & \\
\end{longtabu}

\section{Comments}
\subsection{Inline comments}
\begin{longtabu} to 0.75\linewidth { X X }
	C \newline
    C++ \newline
    Java \newline
    Scala & \lstinline$// comment$ \\
	\\[-0.3em]
	Python \newline
    Perl \newline
    Ruby & \lstinline$# comment$ \\
	\\[-0.3em]
	Lisp & \lstinline$; comment$ \\
	Haskell & \lstinline$-- comment$ \\
	Erlang & \lstinline$\% comment$ \\
	Fortran & \lstinline$! comment$ \\
\end{longtabu}

\subsection{Block comments \& docstrings}
\begin{longtabu} to 0.75\linewidth { X X }
	C \newline
    C++ \newline
    Java \newline
    Scala & \lstinline$/* comment */$ \\
    \\[-0.3em]
	Python & \lstinline$""" docstring """$ \\
    Perl (part of POD) & \lstinline$=for comment$ \newline
    \lstinline$comment$ \newline
    \lstinline$=cut$  \\
	\\[-0.3em]
    Ruby & \lstinline$=begin$ \newline
    \lstinline$comment$ \newline
    \lstinline$=end$ \\
    \\[-0.3em]
	Lisp & \lstinline$#| comment |#$ \\
	Haskell & \lstinline$\{- comment -\}$ \\
\end{longtabu}
more: \url{http://en.wikipedia.org/wiki/Comparison_of_programming_languages_%28syntax%29#Comments}
\section{Boolean and Logical Operators}
\begin{longtabu} to 0.75\linewidth{ X X X  X X X X }
	Language & And & Or & Not & Type & True & False \\
	\hline
	Haskell & \lstinline$\&\&$ & \lstinline$||$ & \lstinline$not$ & \lstinline$Bool$ & \lstinline$True$ & \lstinline$False$ \\
\end{longtabu}

\section{Folds}
\begin{longtabu} to 0.75\linewidth { X X X }
	Language & Fold left & Fold right \\
	\hline
	Haskell & \lstinline$foldl' (\ xs x -> x : xs) [] [1, 2, 3]$ & \lstinline$foldr' fn li$ \\
\end{longtabu}

\section{Gotchas}
\begin{itemize}
	\item Quot truncates towards 0, and rem has the same sign as the dividend. Div truncates towards negative infinity, and mod has the same sign as the divisor
\end{itemize}

\section{To add}
\begin{itemize}
	\item literals
	\item car/cdr (haskell fst snd)
	\item scheme fold is (lambda (x accum) accum)
	\item hex characters
	\item erlang map
	\item string format
\end{itemize}

\section{To learn}
\begin{itemize}
	\item perl
	\item pascal
	\item cobol
	\item fortran
	\item lua
	\item R
	\item ocaml
	\item go
	\item groovy
\end{itemize}

\end{document}
